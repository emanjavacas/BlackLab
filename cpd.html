<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia at 2016-08-23 
 | Rendered using Apache Maven Fluido Skin 1.4
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20160823" />
    <meta http-equiv="Content-Language" content="en" />
    <title>BlackLab &#x2013; CPD Results</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.4.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />

      
    <script type="text/javascript" src="./js/apache-maven-fluido-1.4.min.js"></script>

                          
        
<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Nunito:300"/>
          
                  </head>
        <body class="topBarDisabled">
          
                
                    
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                                                                                                <img src="images/logo-blacklab.png"  alt="BlackLab"/>
                </div>
                      </div>
        <div class="pull-right">                  <a href="http://www.inl.nl/" id="bannerRight">
                                                                                                <img src="images/logo-inl.png"  alt="INL"/>
                </a>
      </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
                    
                              <li class="">
                    <a href="http://www.inl.nl/" class="externalLink" title="INL">
        INL</a>
                    <span class="divider">/</span>
      </li>
            <li class="">
                    <a href="index.html" title="BlackLab">
        BlackLab</a>
                    <span class="divider">/</span>
      </li>
        <li class="active ">CPD Results</li>
        
                
                    
                  <li id="publishDate" class="pull-right"><span class="divider">|</span> Last Published: 2016-08-23</li>
              <li id="projectVersion" class="pull-right">
                    Version: 1.6.0-SNAPSHOT
        </li>
            
                            </ul>
      </div>

            
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
                
                    
                <ul class="nav nav-list">
                    <li class="nav-header">BlackLab</li>
                              
      <li>
  
                          <a href="index.html" title="Introduction">
          <span class="none"></span>
        Introduction</a>
            </li>
                                                                                                                                                                                                            
      <li>
  
                          <a href="learn.html" title="Learn">
          <span class="icon-chevron-down"></span>
        Learn</a>
                    <ul class="nav nav-list">
                    
      <li>
  
                          <a href="getting-started.html" title="Getting Started">
          <span class="none"></span>
        Getting Started</a>
            </li>
                    
      <li>
  
                          <a href="corpus-query-language.html" title="Corpus Query Language">
          <span class="none"></span>
        Corpus Query Language</a>
            </li>
                    
      <li>
  
                          <a href="blacklab-server-overview.html" title="BlackLab Server overview">
          <span class="none"></span>
        BlackLab Server overview</a>
            </li>
                    
      <li>
  
                          <a href="blacklab-server-different-languages.html" title="Using BlackLab Server from different languages">
          <span class="none"></span>
        Using BlackLab Server from different languages</a>
            </li>
                    
      <li>
  
                          <a href="indexing-with-blacklab.html" title="Indexing with BlackLab">
          <span class="none"></span>
        Indexing with BlackLab</a>
            </li>
                    
      <li>
  
                          <a href="add-input-format.html" title="Add An Input Format">
          <span class="none"></span>
        Add An Input Format</a>
            </li>
                    
      <li>
  
                          <a href="improve-search-speed.html" title="Improve Search Speed">
          <span class="none"></span>
        Improve Search Speed</a>
            </li>
                    
      <li>
  
                          <a href="apidocs/index.html" title="API reference">
          <span class="none"></span>
        API reference</a>
            </li>
                    
      <li>
  
                          <a href="file-formats.html" title="File formats">
          <span class="none"></span>
        File formats</a>
            </li>
              </ul>
        </li>
                
      <li>
  
                          <a href="downloads.html" title="Downloads">
          <span class="none"></span>
        Downloads</a>
            </li>
                
      <li>
  
                          <a href="faq.html" title="FAQ">
          <span class="none"></span>
        FAQ</a>
            </li>
                
      <li>
  
                          <a href="changelog.html" title="Change Log">
          <span class="none"></span>
        Change Log</a>
            </li>
                
      <li>
  
                          <a href="roadmap.html" title="Road Map">
          <span class="none"></span>
        Road Map</a>
            </li>
                
      <li>
  
                          <a href="newsletter.html" title="Newsletter">
          <span class="none"></span>
        Newsletter</a>
            </li>
                              <li class="nav-header">Project Documentation</li>
                                                                                                                                                                                                                                
      <li>
  
                          <a href="project-info.html" title="Project Information">
          <span class="icon-chevron-right"></span>
        Project Information</a>
                  </li>
                                                                                                                                                                                                                                                                
      <li>
  
                          <a href="project-reports.html" title="Project Reports">
          <span class="icon-chevron-down"></span>
        Project Reports</a>
                    <ul class="nav nav-list">
                    
      <li>
  
                          <a href="surefire-report.html" title="Surefire Report">
          <span class="none"></span>
        Surefire Report</a>
            </li>
                    
      <li>
  
                          <a href="apidocs/index.html" title="JavaDocs">
          <span class="none"></span>
        JavaDocs</a>
            </li>
                    
      <li>
  
                          <a href="xref/index.html" title="Source Xref">
          <span class="none"></span>
        Source Xref</a>
            </li>
                    
      <li>
  
                          <a href="xref-test/index.html" title="Test Source Xref">
          <span class="none"></span>
        Test Source Xref</a>
            </li>
                    
      <li>
  
                          <a href="findbugs.html" title="FindBugs">
          <span class="none"></span>
        FindBugs</a>
            </li>
                    
      <li class="active">
  
            <a href="#"><span class="none"></span>CPD</a>
          </li>
                    
      <li>
  
                          <a href="pmd.html" title="PMD">
          <span class="none"></span>
        PMD</a>
            </li>
                    
      <li>
  
                          <a href="checkstyle.html" title="Checkstyle">
          <span class="none"></span>
        Checkstyle</a>
            </li>
                    
      <li>
  
                          <a href="taglist.html" title="Tag List">
          <span class="none"></span>
        Tag List</a>
            </li>
                    
      <li>
  
                          <a href="dependency-updates-report.html" title="Dependency Updates Report">
          <span class="none"></span>
        Dependency Updates Report</a>
            </li>
                    
      <li>
  
                          <a href="plugin-updates-report.html" title="Plugin Updates Report">
          <span class="none"></span>
        Plugin Updates Report</a>
            </li>
              </ul>
        </li>
            </ul>
                
                    
                
          <hr />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
                
        <div id="bodyColumn"  class="span10" >
                                  
            <div class="section">
<h2><a name="CPD_Results"></a>CPD Results</h2>
<p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 5.3.2.</p></div>
<div class="section">
<h2><a name="Duplications"></a>Duplications</h2>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L129">129</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerWhiteLab2.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerWhiteLab2.html#L181">181</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>					propPunct.addValue(&quot; &quot;);
				}
			}
		});

		// lemma element: contains lemma
		addHandler(&quot;lemma&quot;, new ElementHandler() {
			@Override
			public void startElement(String uri, String localName, String qName,
					Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				String set = attributes.getValue(&quot;set&quot;);
				boolean isSetLess = set == null || set.length() == 0;
				boolean isFrog = !isSetLess &amp;&amp; set.equals(&quot;http://ilk.uvt.nl/folia/sets/frog-mblem-nl&quot;);
				if (numLemmaAnnotations == 2 &amp;&amp; isFrog ||
					numLemmaAnnotations == 1 &amp;&amp; isSetLess) {
					// If there were 2 lemma annotation meta declarations,
					// we should use the frog ones; if only 1, the ones
					// without a &quot;set&quot; attribute.
					lemma = attributes.getValue(&quot;class&quot;);
					if (lemma == null)
						lemma = &quot;&quot;;
				}
			}
		});

		// pos element: contains part of speech
		addHandler(&quot;pos&quot;, new ElementHandler() {
			@Override
			public void startElement(String uri, String localName, String qName,
					Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				String set = attributes.getValue(&quot;set&quot;);
				boolean isSetLess = set == null || set.length() == 0;
				boolean isFrog = !isSetLess &amp;&amp; set.equals(&quot;http://ilk.uvt.nl/folia/sets/frog-mbpos-cgn&quot;);
				if (numPosAnnotations == 2 &amp;&amp; isFrog ||
					numPosAnnotations == 1 &amp;&amp; isSetLess) {
					// If there were 2 pos annotation meta declarations,
					// we should use the frog ones; if only 1, the ones
					// without a &quot;set&quot; attribute.
					pos = attributes.getValue(&quot;class&quot;);
					if (pos == null)
						pos = &quot;&quot;;
					// Capture the features inside this pos element (and add the head PoS now)
					capturePosFeatures = true;
					posFeatures.clear();
					String posHead = pos.contains(&quot;(&quot;) ? pos.substring(0, pos.indexOf(&quot;(&quot;)).trim() : pos;
					posFeatures.put(&quot;head&quot;, posHead);
				}
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				capturePosFeatures = false; // we have all the features
				super.endElement(uri, localName, qName);
			}

		});

		// pos/feat element: contains a part of speech feature
		addHandler(&quot;pos/feat&quot;, new ElementHandler() {
			@Override
			public void startElement(String uri, String localName, String qName,
					Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				if (capturePosFeatures) {
					String featSubset = attributes.getValue(&quot;subset&quot;);
					String featClass = attributes.getValue(&quot;class&quot;);
					posFeatures.put(featSubset, featClass);
				}
			}
		});

		// t (token) element directly under w (word) element: contains the word form
		addHandler(&quot;w/t&quot;, new ContentCapturingHandler() {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L225">225</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerWhiteLab2.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerWhiteLab2.html#L347">347</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		addHandler(&quot;s&quot;, new InlineTagHandler());

		// Paragraph tags: index as tags in the content
		addHandler(&quot;p&quot;, new InlineTagHandler());

		// &lt;event/&gt; tags: index as tags in the content
		addHandler(&quot;event&quot;, new InlineTagHandler());

		// meta elements: metadata fields
		// [NOT USED FOR OPENSONAR..?]
		addHandler(&quot;meta&quot;, new ContentCapturingHandler() {


			private String metadataFieldName;

			/** Open tag: add metadata field */
			@Override
			public void startElement(String uri, String localName, String qName, Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				metadataFieldName = attributes.getValue(&quot;id&quot;);
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				super.endElement(uri, localName, qName);
				if (metadataFieldName != null)
					addMetadataField(metadataFieldName, getElementContent());
			}
		});
	}

	/*
	List&lt;String&gt; untokenizedFields = Arrays.asList(
		&quot;Country&quot;,
		&quot;LicentieCode&quot;,
		&quot;LicenseDetails&quot;,
		&quot;CollectionName&quot;
	);
	*/

	@Override
	public void addMetadataField(String name, String value) {

		/*
		// FIXME HACK: See if we need to substitute token-ending characters
		if (untokenizedFields.contains(name)) {
			// Yes; substitute token-ending characters for underscore in these fields!
			value = value.replaceAll(&quot;[\\s\\./]&quot;, &quot;_&quot;);
		}
		*/

		super.addMetadataField(name, value);
	}

	public static void main(String[] args) {
		System.out.println(&quot;NL B&quot;.replaceAll(&quot;[\\s\\./]&quot;, &quot;_&quot;));
		System.out.println(&quot;NL/B&quot;.replaceAll(&quot;[\\s\\./]&quot;, &quot;_&quot;));
		System.out.println(&quot;a.b.c.d&quot;.replaceAll(&quot;[\\s\\./]&quot;, &quot;_&quot;));
	}

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/TextPatternDocLevelAnd.java</td>
<td><a href="./xref/nl/inl/blacklab/search/TextPatternDocLevelAnd.html#L42">42</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/TextPatternOr.java</td>
<td><a href="./xref/nl/inl/blacklab/search/TextPatternOr.html#L123">123</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		if (obj instanceof TextPatternDocLevelAnd) {
			return super.equals(obj);
		}
		return false;
	}

	@Override
	public boolean hasConstantLength() {
		int l = clauses.get(0).getMinLength();
		for (TextPattern clause: clauses) {
			if (!clause.hasConstantLength() || clause.getMinLength() != l)
				return false;
		}
		return true;
	}

	@Override
	public int getMinLength() {
		int n = Integer.MAX_VALUE;
		for (TextPattern clause: clauses) {
			n = Math.min(n, clause.getMinLength());
		}
		return n;
	}

	@Override
	public int getMaxLength() {
		int n = 0;
		for (TextPattern clause: clauses) {
			int l = clause.getMaxLength();
			if (l &lt; 0)
				return -1; // infinite
			n = Math.max(n, l);
		}
		return n;
	}

	@Deprecated
	@Override
	public String toString(QueryExecutionContext context) {
		return &quot;DOC-AND(&quot; + clausesToString(clauses, context) + &quot;)&quot;;</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/testutil/BatchContentStore.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchContentStore.html#L68">68</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/testutil/BatchForwardIndex.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchForwardIndex.html#L63">63</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		System.err.println(&quot;done. [#docs: &quot; + cs.getDocIds().size() + &quot;]&quot;);

		System.out.println(&quot;First\tNumber\tSkip\tSnippets\tTime&quot;);

		for (String query : FileUtil.readLines(inputFile)) {
			query = query.trim();
			if (query.length() == 0 || query.charAt(0) == '#')
				continue; // skip empty lines and #-comments
			String[] numberStr = query.split(&quot;\\s+&quot;);
			int[] numbers = new int[numberStr.length];
			try {
				for (int i = 0; i &lt; numberStr.length; i++) {
					numbers[i] = Integer.parseInt(numberStr[i]);
				}

				int first = numbers[0];
				int number = numbers.length &gt; 1 ? numbers[1] : 100;
				int skip = numbers.length &gt; 2 ? numbers[2] : 0;
				int snippets = numbers.length &gt; 3 ? numbers[3] : 5;
				long time = doPerformanceTest(cs, first, number, skip, snippets);</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDir.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDir.html#L292">292</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.html#L652">652</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			throw ExUtil.wrapRuntimeException(e);
		}
	}

	/**
	 * Get a data File object, given the data file id.
	 *
	 * @param fileId
	 *            the data file id
	 * @return the File object
	 */
	private File getContentFile(int fileId) {
		File f = new File(dir, String.format(&quot;data%04d.dat&quot;, fileId));
		return f;
	}

	/**
	 * Retrieve content with given id
	 *
	 * @param id
	 *            the id
	 * @return the string
	 */
	@Override
	public String retrieve(int id) {
		String[] rv = retrieveParts(id, new int[] { -1 }, new int[] { -1 });
		return rv == null ? null : rv[0];
	}

	/**
	 * Retrieve one or more substrings from the specified content.
	 *
	 * This is more efficient than retrieving the whole content, or retrieving parts in separate
	 * calls, because the file is only opened once and random access is used to read only the
	 * required parts.
	 *
	 * NOTE: if offset and length are both -1, retrieves the whole content. This is used by the
	 * retrieve(id) method.
	 *
	 * @param contentId
	 *            id of the entry to get substrings from
	 * @param start
	 *            the starting points of the substrings (in characters)
	 * @param end
	 *            the end points of the substrings (in characters)
	 * @return the parts
	 */
	@Override
	public synchronized String[] retrieveParts(int contentId, int[] start, int[] end) {
		try {
			TocEntry e = toc.get(contentId);
			if (e == null || e.deleted)
				return null;

			int n = start.length;
			if (n != end.length)
				throw new IllegalArgumentException(&quot;start and end must be of equal length&quot;);
			String[] result = new String[n];</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.html#L380">380</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.html#L351">351</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		nextId = 1;
	}

	private void mapToc(boolean writeable) throws IOException {
		tocRaf = new RandomAccessFile(tocFile, writeable ? &quot;rw&quot; : &quot;r&quot;);
		long fl = tocFile.length();
		if (writeable) {
			fl += writeMapReserve;
		} // leave 1M room at the end
		tocFileChannel = tocRaf.getChannel();
		tocFileBuffer = tocFileChannel.map(writeable ? MapMode.READ_WRITE : MapMode.READ_ONLY, 0, fl);
	}

	private void closeMappedToc() {
		if (tocFileBuffer == null)
			return; // not mapped
		try {
			tocFileChannel.close();
			tocFileChannel = null;
			tocRaf.close();
			tocRaf = null;

			tocFileBuffer = null;

		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * Read the table of contents from the file
	 */
	private void readToc() {
		toc.clear();
		try {
			mapToc(false);
			try {
				tocFileBuffer.position(0);
				int n = tocFileBuffer.getInt();</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/testutil/BatchContentStore.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchContentStore.html#L29">29</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/testutil/BatchQuery.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchQuery.html#L29">29</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>				} else {
					System.err.println(&quot;Illegal option: &quot; + arg);
					usage();
					return;
				}
			} else {
				switch (fileArgNumber) {
				case 0:
					indexDir = new File(arg);
					if (!indexDir.exists() || !indexDir.isDirectory()) {
						System.err.println(&quot;Index directory not found: &quot; + arg);
						usage();
						return;
					}
					break;
				case 1:
					inputFile = new File(arg);
					if (!inputFile.exists()) {
						System.err.println(&quot;Input file not found: &quot; + arg);
						usage();
						return;
					}
					break;
				default:
					System.err.println(&quot;Too many file arguments (supply index dir and input file)&quot;);
					usage();
					return;
				}
				fileArgNumber++;
			}
		}
		if (fileArgNumber &lt; 2) {
			System.err.println(&quot;Too few file arguments (supply index dir and input file)&quot;);
			usage();
			return;
		}

		System.err.print(&quot;Opening content store... &quot;);</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.html#L687">687</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.html#L718">718</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			try (FileInputStream fileInputStream = new FileInputStream(contentsFile)) {
				try (FileChannel fileChannel = fileInputStream.getChannel()) {
					// Retrieve the strings requested
					for (int i = 0; i &lt; n; i++) {
						int a = start[i];
						int b = end[i];

						if (a == -1)
							a = 0;
						if (b == -1)
							b = e.entryLengthCharacters;

						// Check values
						if (a &lt; 0 || b &lt; 0) {
							throw new IllegalArgumentException(&quot;Illegal values, start = &quot; + a + &quot;, end = &quot; + b);
						}
						if (a &gt; e.entryLengthCharacters || b &gt; e.entryLengthCharacters) {
							throw new IllegalArgumentException(&quot;Value(s) out of range, start = &quot; + a
									+ &quot;, end = &quot; + b + &quot;, content length = &quot; + e.entryLengthCharacters);
						}
						if (b &lt;= a) {
							throw new IllegalArgumentException(
									&quot;Tried to read empty or negative length snippet (from &quot; + a
											+ &quot; to &quot; + b + &quot;)&quot;);
						}

						// 1 - determine what blocks to read
						int firstBlock = -1, lastBlock = -1;</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/index/DocIndexerXml.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXml.html#L160">160</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/index/DocIndexerXmlHandlers.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXmlHandlers.html#L599">599</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		escapeBuilder.delete(0, escapeBuilder.length());
		int start = 0;
		char[] srcArr = new char[source.length()];
		source.getChars(0, source.length(), srcArr, 0);
		int end = source.length();
		for (int i = 0; i &lt; end; i++) {
			char c = srcArr[i]; // source.charAt(i);
			if (c == '&lt;' || c == '&gt;' || c == '&amp;' || c == '&quot;') {
				escapeBuilder.append(srcArr, start, i - start); // source.substring(start, i));
				switch (c) {
				case '&lt;':
					escapeBuilder.append(&quot;&amp;lt;&quot;);
					break;
				case '&gt;':
					escapeBuilder.append(&quot;&amp;gt;&quot;);
					break;
				case '&amp;':
					escapeBuilder.append(&quot;&amp;amp;&quot;);
					break;
				case '&quot;':
					escapeBuilder.append(&quot;&amp;quot;&quot;);
					break;</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.html#L635">635</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.html#L666">666</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>	}

	/**
	 * Retrieve content with given id
	 *
	 * @param id
	 *            the id
	 * @return the string
	 */
	@Override
	public String retrieve(int id) {
		String[] rv = retrieveParts(id, new int[] { -1 }, new int[] { -1 });
		return rv == null ? null : rv[0];
	}

	/**
	 * Retrieve one or more substrings from the specified content.
	 *
	 * This is more efficient than retrieving the whole content, or retrieving parts in separate
	 * calls, because the file is only opened once and random access is used to read only the
	 * required parts.
	 *
	 * NOTE: if offset and length are both -1, retrieves the whole content. This is used by the
	 * retrieve(id) method.
	 *
	 * @param contentId
	 *            id of the entry to get substrings from
	 * @param start
	 *            the starting points of the substrings (in characters).
	 *            -1 means &quot;start of document&quot;
	 * @param end
	 *            the end points of the substrings (in characters).
	 *            -1 means &quot;end of document&quot;
	 * @return the parts
	 */
	@Override
	public synchronized String[] retrieveParts(int contentId, int[] start, int[] end) {
		try {
			// Find the correct TOC entry
			TocEntry e = toc.get(contentId);
			if (e == null || e.deleted)
				return null;

			// Sanity-check parameters
			int n = start.length;
			if (n != end.length)
				throw new IllegalArgumentException(&quot;start and end must be of equal length&quot;);

			// Create array for results
			String[] result = new String[n];

			// Open the file
			try (FileInputStream fileInputStream = new FileInputStream(contentsFile)) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.html#L452">452</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.html#L413">413</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>					freeBlocks.add(i);
			}

		} catch (Exception e) {
			throw ExUtil.wrapRuntimeException(e);
		}
	}

	private void writeToc() {
		try {
			mapToc(true);
			tocFileBuffer.putInt(toc.size());
			try {
				for (TocEntry e : toc.values()) {
					if (tocFileBuffer.remaining() &lt; e.sizeBytes()) {
						// Close and re-open with extra writing room
						int p = tocFileBuffer.position();
						closeMappedToc();
						mapToc(true);
						tocFileBuffer.position(p);
					}
					e.serialize(tocFileBuffer);
				}
			} finally {
				closeMappedToc();
			}
		} catch (Exception e) {
			throw ExUtil.wrapRuntimeException(e);
		}
		tocModified = false;
	}

	/**
	 * Close the content store. Writes the table of contents (if modified)
	 */
	@Override
	public void close() {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/sequences/SpansExpansionRaw.java</td>
<td><a href="./xref/nl/inl/blacklab/search/sequences/SpansExpansionRaw.html#L100">100</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/sequences/SpansFilterNGramsRaw.java</td>
<td><a href="./xref/nl/inl/blacklab/search/sequences/SpansFilterNGramsRaw.html#L99">99</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		this.min = min;
		this.max = max;
		if (max != -1 &amp;&amp; min &gt; max)
			throw new IllegalArgumentException(&quot;min &gt; max&quot;);
		if (min &lt; 0 || max &lt; -1)
			throw new IllegalArgumentException(&quot;Expansions cannot be negative&quot;);
	}

	/** For test, we don't have an index reader, so use default values (all docs are 5 tokens long)
	 * @param b true if we're testing, false if not */
	public void setTest(boolean b) {
		if (lengthGetter != null)
			lengthGetter.setTest(b);
	}

	@Override
	public int docID() {
		return currentDoc;
	}

	@Override
	public int endPosition() {
		if (alreadyAtFirstHit)
			return -1; // .nextStartPosition() not called yet
		return end;
	}

	@Override
	public int nextDoc() throws IOException {
		alreadyAtFirstHit = false;
		if (currentDoc != NO_MORE_DOCS) {
			do {
				currentDoc = clause.nextDoc();
				if (currentDoc == NO_MORE_DOCS)
					return NO_MORE_DOCS;</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/index/DocIndexerXml.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXml.html#L206">206</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/index/DocIndexerXmlHandlers.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXmlHandlers.html#L646">646</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		escapeBuilder.delete(0, escapeBuilder.length());
		int end = start + length;
		for (int i = start; i &lt; end; i++) {
			char c = source[i];
			if (c == '&lt;' || c == '&gt;' || c == '&amp;' || c == '&quot;') {
				escapeBuilder.append(source, start, i - start);
				switch (c) {
				case '&lt;':
					escapeBuilder.append(&quot;&amp;lt;&quot;);
					break;
				case '&gt;':
					escapeBuilder.append(&quot;&amp;gt;&quot;);
					break;
				case '&amp;':
					escapeBuilder.append(&quot;&amp;amp;&quot;);
					break;
				case '&quot;':
					escapeBuilder.append(&quot;&amp;quot;&quot;);
					break;
				}
				start = i + 1;
			}
		}
		escapeBuilder.append(source, start, end - start);
		return escapeBuilder.toString();
	}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDir.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDir.html#L306">306</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.html#L635">635</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>	}

	/**
	 * Retrieve content with given id
	 *
	 * @param id
	 *            the id
	 * @return the string
	 */
	@Override
	public String retrieve(int id) {
		String[] rv = retrieveParts(id, new int[] { -1 }, new int[] { -1 });
		return rv == null ? null : rv[0];
	}

	/**
	 * Retrieve one or more substrings from the specified content.
	 *
	 * This is more efficient than retrieving the whole content, or retrieving parts in separate
	 * calls, because the file is only opened once and random access is used to read only the
	 * required parts.
	 *
	 * NOTE: if offset and length are both -1, retrieves the whole content. This is used by the
	 * retrieve(id) method.
	 *
	 * @param contentId
	 *            id of the entry to get substrings from
	 * @param start
	 *            the starting points of the substrings (in characters)
	 * @param end
	 *            the end points of the substrings (in characters)
	 * @return the parts
	 */
	@Override
	public synchronized String[] retrieveParts(int contentId, int[] start, int[] end) {
		try {
			TocEntry e = toc.get(contentId);
			if (e == null || e.deleted)
				return null;

			int n = start.length;
			if (n != end.length)
				throw new IllegalArgumentException(&quot;start and end must be of equal length&quot;);
			String[] result = new String[n];</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/perdocument/DocPropertyMultiple.java</td>
<td><a href="./xref/nl/inl/blacklab/perdocument/DocPropertyMultiple.html#L111">111</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/grouping/HitPropertyMultiple.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyMultiple.html#L150">150</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		for (DocProperty crit : criteria) {
			if (b.length() &gt; 0)
				b.append(&quot;, &quot;);
			b.append(crit.getName());
		}
		return b.toString();
	}

	@Override
	public String serialize() {
		String[] values = new String[criteria.size()];
		for (int i = 0; i &lt; criteria.size(); i++) {
			values[i] = criteria.get(i).serialize();
		}
		return (reverse ? &quot;-(&quot; : &quot;&quot;) + PropValSerializeUtil.combineMultiple(values) + (reverse ? &quot;)&quot; : &quot;&quot;);
	}

	public static DocPropertyMultiple deserialize(String info) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.html#L336">336</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirZip.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirZip.html#L51">51</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		final int POOL_SIZE = 10;
		compresserPool = new SimpleResourcePool&lt;Deflater&gt;(POOL_SIZE){
			@Override
			public Deflater createResource() {
				return new Deflater();
			}

			@Override
			public void destroyResource(Deflater resource) {
				resource.end();
			}
		};
		decompresserPool = new SimpleResourcePool&lt;Inflater&gt;(POOL_SIZE){
			@Override
			public Inflater createResource() {
				return new Inflater();
			}

			@Override
			public void destroyResource(Inflater resource) {
				resource.end();
			}
		};
		zipbufPool = new SimpleResourcePool&lt;byte[]&gt;(POOL_SIZE){
			@Override
			public byte[] createResource() {
				return new byte[MAX_BLOCK_SIZE_BYTES+1]; // one larger to detect when buffer space was insufficient</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerFolia.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerFolia.html#L99">99</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L199">199</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			}
		});

		// t (token) element directly under w (word) element: contains the word form
		addHandler(&quot;w/t&quot;, new ContentCapturingHandler() {

			/** Tokens with a class attribute are (usually?) the original scanned token before correction,
			 *  so we skip them */
			boolean isOcr;

			@Override
			public void startElement(String uri, String localName, String qName,
					Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				isOcr = attributes.getValue(&quot;class&quot;) != null;
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				super.endElement(uri, localName, qName);
				if (!isOcr)
					wordform = getElementContent();
			}
		});

		// Sentence tags: index as tags in the content
		addHandler(&quot;s&quot;, new InlineTagHandler());

		// Paragraph tags: index as tags in the content
		addHandler(&quot;p&quot;, new InlineTagHandler());

		// meta elements: metadata fields
		addHandler(&quot;meta&quot;, new ContentCapturingHandler() {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/TextPatternContaining.java</td>
<td><a href="./xref/nl/inl/blacklab/search/TextPatternContaining.html#L48">48</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/TextPatternWithin.java</td>
<td><a href="./xref/nl/inl/blacklab/search/TextPatternWithin.html#L47">47</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			return super.equals(obj) &amp;&amp; ((TextPatternContaining)obj).invert == invert;
		}
		return false;
	}

	@Override
	public boolean hasConstantLength() {
		return clauses.get(0).hasConstantLength();
	}

	@Override
	public int getMinLength() {
		return clauses.get(0).getMinLength();
	}

	@Override
	public int getMaxLength() {
		return clauses.get(0).getMaxLength();
	}

	@Override
	public int hashCode() {
		return super.hashCode() + (invert ? 13 : 0);
	}

	@Override
	public String toString(QueryExecutionContext context) {
		return &quot;CONTAINING(&quot; + clauses.get(0).toString(context) + &quot;, &quot; + clauses.get(1).toString(context) + &quot;)&quot;;</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/grouping/HitPropertyHitText.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyHitText.html#L54">54</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/grouping/HitPropertyLeftContext.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyLeftContext.html#L54">54</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/search/grouping/HitPropertyRightContext.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyRightContext.html#L54">54</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/grouping/HitPropertyWordLeft.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyWordLeft.html#L55">55</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/search/grouping/HitPropertyWordRight.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyWordRight.html#L54">54</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>	public HitPropertyHitText(Hits hits, String field, String property, boolean sensitive) {
		super(hits);
		this.searcher = hits.getSearcher();
		if (property == null || property.length() == 0) {
			this.luceneFieldName = ComplexFieldUtil.mainPropertyField(searcher.getIndexStructure(), field);
			this.propName = ComplexFieldUtil.getDefaultMainPropName();
		} else {
			this.luceneFieldName = ComplexFieldUtil.propertyField(field, property);
			this.propName = property;
		}

		this.terms = searcher.getTerms(luceneFieldName);
		this.sensitive = sensitive;
	}

	public HitPropertyHitText(Hits hits, String field, boolean sensitive) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerFolia.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerFolia.html#L99">99</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L199">199</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerWhiteLab2.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerWhiteLab2.html#L300">300</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			}
		});

		// t (token) element directly under w (word) element: contains the word form
		addHandler(&quot;w/t&quot;, new ContentCapturingHandler() {

			/** Tokens with a class attribute are (usually?) the original scanned token before correction,
			 *  so we skip them */
			boolean isOcr;

			@Override
			public void startElement(String uri, String localName, String qName,
					Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				isOcr = attributes.getValue(&quot;class&quot;) != null;
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				super.endElement(uri, localName, qName);
				if (!isOcr)
					wordform = getElementContent();
			}
		});

		// Sentence tags: index as tags in the content
		addHandler(&quot;s&quot;, new InlineTagHandler());</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerFolia.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerFolia.html#L128">128</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L231">231</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerWhiteLab2.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerWhiteLab2.html#L353">353</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>		addHandler(&quot;p&quot;, new InlineTagHandler());

		// meta elements: metadata fields
		addHandler(&quot;meta&quot;, new ContentCapturingHandler() {

			private String metadataFieldName;

			/** Open tag: add metadata field */
			@Override
			public void startElement(String uri, String localName, String qName, Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				metadataFieldName = attributes.getValue(&quot;id&quot;);
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				super.endElement(uri, localName, qName);
				if (metadataFieldName != null)
					addMetadataField(metadataFieldName, getElementContent());
			}
		});
	}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L75">75</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerWhiteLab2.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerWhiteLab2.html#L97">97</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>		final ComplexFieldProperty propPartOfSpeech = addProperty(&quot;pos&quot;);

		// Doc element: the individual documents to index
		addHandler(&quot;/FoLiA&quot;, new DocumentElementHandler());

		// PoS annotation metadata: see which annotation we need to use.
		addHandler(&quot;pos-annotation&quot;, new ElementHandler() {
			@Override
			public void startElement(String uri, String localName,
					String qName, Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				numPosAnnotations++;
			}
		});

		// Lemma annotation metadata: see which annotation we need to use.
		addHandler(&quot;lemma-annotation&quot;, new ElementHandler() {
			@Override
			public void startElement(String uri, String localName,
					String qName, Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				numLemmaAnnotations++;
			}
		});

		// Word elements: index as main contents
		addHandler(&quot;w&quot;, new WordHandlerBase() {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/search/lucene/SpansPositionFilter.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpansPositionFilter.html#L260">260</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/search/lucene/SpansPositionFilter.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpansPositionFilter.html#L316">316</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>			case CONTAINING:
				// Looking for producer hits with a filter hit inside
				while (min &lt;= max) {
					int i = (min + max) / 2;
					if (filterFixedLength &amp;&amp; filter.endPosition(i) &gt; producer.endPosition() + rightAdjust) {
						// Filter end position to the right of producer hit end position.
						max = i - 1;
					} else if (filter.startPosition(i) &lt; producerStart + leftAdjust) {
						// Filter start position to the left of producer hit start position.
						min = i + 1;
					} else {
						// Can't narrow down the edges any further; do linear search from here.
						break;
					}
				}
				for (int i = min; i &lt;= max; i++) {
					if (filter.startPosition(i) &gt;= producerStart + leftAdjust &amp;&amp; filter.endPosition(i) &lt;= producer.endPosition() + rightAdjust) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/testutil/BatchContentStore.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchContentStore.html#L35">35</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/testutil/BatchForwardIndex.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchForwardIndex.html#L31">31</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/testutil/BatchQuery.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchQuery.html#L35">35</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>				switch (fileArgNumber) {
				case 0:
					indexDir = new File(arg);
					if (!indexDir.exists() || !indexDir.isDirectory()) {
						System.err.println(&quot;Index directory not found: &quot; + arg);
						usage();
						return;
					}
					break;
				case 1:
					inputFile = new File(arg);
					if (!inputFile.exists()) {
						System.err.println(&quot;Input file not found: &quot; + arg);
						usage();
						return;
					}
					break;
				default:
					System.err.println(&quot;Too many file arguments (supply index dir and input file)&quot;);
					usage();
					return;
				}
				fileArgNumber++;
			}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerFolia.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerFolia.html#L52">52</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L98">98</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		addHandler(&quot;/FoLiA&quot;, new DocumentElementHandler());

		// Word elements: index as main contents
		addHandler(&quot;w&quot;, new WordHandlerBase() {

			@Override
			public void startElement(String uri, String localName, String qName,
					Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				wordform = &quot;&quot;;
				pos = &quot;&quot;;
				lemma = &quot;&quot;;
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				super.endElement(uri, localName, qName);
				if (wordform.length() &gt; 0) {
					propMain.addValue(wordform);
					propPartOfSpeech.addValue(pos);</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/util/TimeUtil.java</td>
<td><a href="./xref/nl/inl/util/TimeUtil.html#L50">50</a></td></tr>
<tr class="a">
<td>nl/inl/util/Timer.java</td>
<td><a href="./xref/nl/inl/util/Timer.html#L86">86</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		if (min &gt; 0) {
			result.append(min).append(&quot; &quot;).append(StringUtil.pluralize(&quot;minute&quot;, min)).append(&quot;, &quot;);
		}
		result.append(sec).append(&quot; &quot;).append(StringUtil.pluralize(&quot;second&quot;, sec));
		if (reportMsec) {
			result.append(&quot;, &quot;).append(msec).append(&quot; &quot;).append(StringUtil.pluralize(&quot;millisecond&quot;, msec));
		}
		return result.toString();
	}</pre></div></td></tr></table></div>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
                      <div class="row-fluid">
                                      <p >Copyright &copy;                    2016
                        <a href="http://www.inl.nl">Instituut voor Nederlandse Taal (INT)</a>.
            All rights reserved.      
                    
      </p>
                </div>

        
                </div>
    </footer>
        </body>
</html>
